# RSA ASSIGNMENT

## PURPOSE
1. Write a program to implement RSA algorithm with key size 1024 bits.
2. After public key and private key been generated, use Alice/Bob application over TCP to demonstrate encryption and decryption process. Sockets provide the communication mechanism between two computers using TCP. TCP is a two-way communication protocol.

## METHODS
The program consists of two classes one is Alice which present the one who generate the public key pair and send the public key to Bob through TCP socket, then decrypt the ciphertext received from Bob.

The other one is Bob who will use the public key to encrypt the message and send the ciphertext to Alice for decryption. . The input p and q should be generated by random numbers program 

## BOB

Bob is the server which will wait to recieve a public key from the client (Alice). This public key will then be used to encrypt data sent to the client (Alice)

First we are going to import the necessary java classes as well as require the clojure namespaces.

```clojure
(ns io.wakamau.bob
  (:gen-class) 
  (:require
   [clojure.java.io :as io]
   [cheshire.core :as cheshire])
  (:import
   [java.net ServerSocket Socket InetAddress]
   [java.math BigInteger]
   [java.lang System]))
```

Next we are going to define a new-line separator. We do this because our program is intended to run on different systems e.g. LINUX, Windows or Mac.
```clojure
(def new-line (System/getProperty "line.separator"))
```


This is our encrypt function. It takes a map of `e` and `n` as well as the `message` to encrypt. First we map a composed function of `int`, `str` and then create a `BigInteger` instance of the string message. Then we follow that with mapping the following:

Ciphertext = Message <sup>e</sup> mod n

on the `big-message`.
```clojure
(defn encrypt-message
  [{:keys [e n]} message]
  (let [big-message (map (comp #(BigInteger. %) str int) message)]
    (map #(.modPow % e n) big-message)))
```


This is a helper function to stringify the encrypted text in preparation to sending it over the wire.
```clojure
(defn stringify-encryption
  [encryption]
  (cheshire/generate-string encryption))
```


### BOB SERVER CODE

This is the heart of the server code.

We are using the `with-open` macro which will automatically close all the socket connections made when we are done. 

First we are creating a server instance, then getting the address as well as the port. Next we get the socket, then create a `reader` and and `writer` using the `clojure.java.io` library. Next we then wait for the initial text from the client (Alice) then parse that as well as print it. The last thing we do is continuously wait for text from the console and then push that to the client.

```clojure
(defn server
  "takes a port and returns a server that reads from standard input and    pushes that to the client"
  [port]
  (with-open [server-socket (ServerSocket. port)
              address (.getHostAddress (.getInetAddress server-socket))
              port (.getLocalPort server-socket)]
    (println (format "Server is listening on %s:%d" address port))
    (let [socket (.accept server-socket)
          writer (io/writer socket)
          reader (io/reader socket)
          first-text (.readLine reader)
          public-key (cheshire/parse-string first-text true)]
      (println "public key is:  " first-text)
      (loop [txt (read-line)]
        (.write writer (str
                        (stringify-encryption (encrypt-message public-key txt))
                        new-line))
        (.flush writer)
        (println "text sent is:  " txt new-line)
        (recur (read-line))))))
```


### BOB'S HELPER FUNCTIONS

These are helper functions for validation. 
```clojure
(def port-number-regex
  (re-pattern "^(6553[0-5]|655[0-2]\\d|65[0-4]\\d\\d|6[0-4]\\d{3}|[1-5]\\d{4}|[2-9]\\d{3}|1[1-9]\\d{2}|10[3-9]\\d|102[4-9])$"))

(defn is-valid-port?
  [port]
  (re-find (re-matcher port-number-regex (str port))))

(defn get-port
  []
  (println "Please enter host")
  (loop [port (read-line)]
    (if (is-valid-port? port)
      (Integer/parseInt port)
      (recur (do (println "That port is kinda wrong, just try again.")
                 (read-line))))))
```


### BOB's MAIN FUNCTION
Lastly we have our main function. We mainly get the `port` and then pass that to the `server` we have defined above.
```clojure
(defn -main
  [& args]
  (println "Welcome to the [BOB] side of the program a.k.a the sErVeR ;-)")
  (let [port (get-port)]
    (server port)))
```



## ALICE

Next we will look at the code for the client

Similar to what we did with BOB we import all the necessary java classess as well as the clojure namespaces. Notably here we are using the `apache.commons.validator` library in order to validate the address we are being told to listen to.

```clojure
(ns io.wakamau.alice
  (:gen-class) ;; generates compiled byte-code
  (:require
   [clojure.java.io :as io]
   [cheshire.core :as cheshire])
  (:import
   [java.net Socket]
   [java.math BigInteger]
   [java.lang System]
   [java.security SecureRandom]
   [org.apache.commons.validator.routines InetAddressValidator]))
```


The first thing we do is define functions that generate random primes using the `BigInteger` class constructor below.

```java
BigInteger(int bitLength, int certainty, Random rnd)

// Constructs a randomly generated positive BigInteger that is probably prime, with the specified bitLength.

// https://docs.oracle.com/javase/8/docs/api/java/math/BigInteger.html
```


```clojure
(defn- gen-rand-512
  []
  (BigInteger/probablePrime 512 (SecureRandom.)))

(defn- gen-rand-1000
  []
  (BigInteger/probablePrime 1000 (SecureRandom.)))
```


This is how we generate our `e`. After taking `phi` we continuously loop until we get the gcd of `e` and `phi` or the tortient is equal to `1`.

```clojure
(defn gen-e
  [phi]
  (let [e (gen-rand-1000)]
    (loop [e e
           phi phi]
      (if (.equals (BigInteger. "1") (.gcd phi e))
        e
        (recur (gen-rand-1000) phi)))))
```


Next we define our `p`, `q`, `n`, `phi`, `e` and `d`
```clojure
(def p (gen-rand-512))
(def q (gen-rand-512))
(def n (.multiply p q))
(def phi (.multiply (decrement p)
                    (decrement q)))
(def e (gen-e phi))

(def d
  "the private key"
  (.modInverse e phi))
```


This is our decrypt message function. It takes as map of private-key `d` and n as well as the cipher-text to be decrypted. We map the composition of the `modPow` method and the `char` function then we `apply` the `str` function on the result. 

```clojure
(defn decrypt-message
  [{:keys [d n]} cipher-text]
  (let [msg-chars (map (comp char #(.modPow % d n)) cipher-text)]
    (apply str msg-chars)))
```

### ALICE'S SERVER

This is Alice's server or (more appropriately the client). 

Firstly, we create a `Socket` instance, then we subsequently obtain a `reader` and `writer`. We then write to the socket our `public-keys`. Finally, we continuously wait for text from the server, decrypt it then `print` that to the console.

```clojure
(defn server
  "it takes a host and port and then returns a server that continuously    listens for text from the socket connection and printing that to the    console."
  [host port]
  (println "Client is now ready, go to bob's side and start typing away... ;-)")
  (with-open [socket (Socket. host port)
              reader (io/reader socket)
              writer (io/writer socket)
              e-and-n (cheshire/generate-string {:e e :n n})]
    (.write writer (str e-and-n new-line))
    (.flush writer)
    (loop [txt (.readLine reader)]
      (println (str "decrypted text is: "
                    new-line
                    (decrypt-message {:d d :n n}
                                     (cheshire/parse-string txt))
                    new-line))
      (recur (.readLine reader)))))
```


### ALICE'S HELPER FUNCTION
Some helper functions on validation and obtaining the host and port.

```clojure
(defn decrement
  [x]
  (.subtract x (BigInteger. "1")))

(def validator (InetAddressValidator/getInstance))

(def port-number-regex
  (re-pattern "^(6553[0-5]|655[0-2]\\d|65[0-4]\\d\\d|6[0-4]\\d{3}|[1-5]\\d{4}|[2-9]\\d{3}|1[1-9]\\d{2}|10[3-9]\\d|102[4-9])$"))

(defn is-valid-port?
  [port]
  (re-find (re-matcher port-number-regex (str port))))

(defn get-host-and-port
  []
  (println "Please enter the host:  ")
  (loop [host (read-line)]
    (if (.isValid validator host)
      (do (println "Please enter the port:  ")
          (loop [port (read-line)]
            (if (is-valid-port? port)
              {:host host
               :port (Integer/parseInt port)}
              (recur (do (println "That port is kinda wrong, just try again")
                         (read-line))))))
      (recur (do (println "That host is kinda wrong, just try again")
                 (read-line))))))
```


### ALICE'S MAIN FUNCTION

We get the host and port then we pass that to the `server` function defined above. 
```clojure
(defn -main
  [& args]
  (println "Welcome to the [ALICE] side of the program a.k.a the ClIeNT ;-)")
  (let [{:keys [host port]} (get-host-and-port)]
    (server host port)))
```
